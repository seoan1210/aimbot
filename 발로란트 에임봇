import cv2
import numpy as np
from mss import mss
import time
from win32 import win32api
import win32con

# 🕹️ 게임 에임 보조 스크립트 설정

# 🖥️ 모니터 및 캡처 영역 설정
MONITOR_WIDTH = 3440  # 사용하는 모니터의 전체 가로 해상도
MONITOR_HEIGHT = 1920 # 사용하는 모니터의 전체 세로 해상도
CAPTURE_BOX_SIZE = 100 # 화면 중앙에서 캡처할 박스의 한 변 길이 (100x100 픽셀)

# 🎨 추적할 색상(빨간색)의 HSV 범위
# 이 값들은 게임 환경이나 색상에 따라 직접 조정하는 게 좋아!
# OpenCV의 HSV 색 공간을 이용해 원하는 색상을 정확하게 찾아낼 수 있어.
LOWER_COLOR_HSV = np.array([139, 96, 129])
UPPER_COLOR_HSV = np.array([169, 255, 255])

# 🖱️ 화면 캡처 도구 초기화
sct = mss()

def grab_capture_box():
    """
    화면 중앙의 지정된 크기(CAPTURE_BOX_SIZE)만큼 화면을 캡처해.
    
    Returns:
        np.array: 캡처된 이미지 데이터가 담긴 Numpy 배열.
    """
    # 1번 모니터 정보를 가져와 (0번이 전체 모니터, 1번부터 개별 모니터)
    monitor_info = sct.monitors[1]
    
    # 모니터 정중앙에 위치할 캡처 박스 영역을 계산해.
    # 'left'와 'top'은 캡처를 시작할 좌측 상단 좌표야.
    capture_box = {
        'top': monitor_info['top'] + int((MONITOR_HEIGHT / 2) - (CAPTURE_BOX_SIZE / 2)),
        'left': monitor_info['left'] + int((MONITOR_WIDTH / 2) - (CAPTURE_BOX_SIZE / 2)),
        'width': CAPTURE_BOX_SIZE,
        'height': CAPTURE_BOX_SIZE,
    }
    
    # 계산된 영역을 찰칵! 캡처하고 Numpy 배열로 변환해서 반환해줘.
    sct_img = sct.grab(capture_box)
    return np.array(sct_img)

def move_mouse(x_offset, y_offset):
    """
    상대적인 좌표만큼 마우스를 움직이는 함수야.
    
    Args:
        x_offset (int): 마우스를 가로로 움직일 픽셀 수 (음수: 왼쪽, 양수: 오른쪽).
        y_offset (int): 마우스를 세로로 움직일 픽셀 수 (음수: 위쪽, 양수: 아래쪽).
    """
    # win32api를 이용해서 마우스를 부드럽게 움직여.
    win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, x_offset, y_offset, 0, 0)

def is_mouse_button_pressed():
    """
    마우스 왼쪽 또는 오른쪽 버튼이 눌렸는지 확인해주는 함수야.
    
    Returns:
        bool: 마우스 버튼이 하나라도 눌려있으면 True, 아니면 False.
    """
    # GetAsyncKeyState를 사용해서 마우스 버튼의 현재 상태를 체크해.
    return win32api.GetAsyncKeyState(0x01) != 0 or win32api.GetAsyncKeyState(0x02) != 0

def process_and_aim(image):
    """
    캡처한 이미지를 분석해서 목표물을 찾고 마우스를 조작하는 핵심 함수야.
    
    Args:
        image (np.array): 분석할 이미지 데이터.
    """
    # BGR 색상 공간을 HSV 색상 공간으로 변환해줘.
    # HSV는 색상을 명확하게 구분하기에 더 좋거든!
    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    
    # 지정된 HSV 범위 내의 픽셀만 남겨서 마스크를 만들어.
    # 이렇게 하면 우리가 찾는 색상(빨간색)만 '하얗게' 보이고 나머지는 '까맣게' 돼.
    color_mask = cv2.inRange(hsv_image, LOWER_COLOR_HSV, UPPER_COLOR_HSV)
    
    # 마스크에서 물체의 윤곽선을 찾아내!
    contours, _ = cv2.findContours(color_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    # 만약 화면에 빨간색 물체가 보인다면!
    if contours:
        # 여러 윤곽선 중에서 가장 큰 녀석을 목표물로 선택해.
        largest_contour = max(contours, key=cv2.contourArea)
        
        # 목표물의 중심 좌표를 계산하기 위해 모멘트를 사용해.
        moment = cv2.moments(largest_contour)
        
        # 모멘트가 0이 아니어야 정상적으로 중심을 계산할 수 있어.
        if moment["m00"] != 0:
            center_x = int(moment["m10"] / moment["m00"])
            center_y = int(moment["m01"] / moment["m00"])
            
            # 캡처 박스의 중심 좌표를 구해.
            box_center = CAPTURE_BOX_SIZE / 2
            
            # 목표물이 캡처 박스 중심에서 얼마나 떨어져 있는지 계산!
            # 이 값이 바로 마우스를 움직여야 할 양이 돼.
            x_offset = int(center_x - box_center)
            y_offset = int(center_y - box_center)
            
            # 만약 마우스 왼쪽 버튼이 눌려 있다면!
            if is_mouse_button_pressed():
                # 계산된 만큼 마우스를 움직여서 에임을 맞춰줘!
                move_mouse(x_offset, y_offset)
                
            # 디버깅을 위해 목표물 중심에 하얀색 점을 찍어줘.
            # 이렇게 하면 우리가 뭘 보고 있는지 시각적으로 확인할 수 있어!
            cv2.circle(image, (center_x, center_y), 5, (255, 255, 255), -1)

def main():
    """
    스크립트의 모든 기능을 실행하는 메인 루프!
    """
    print("스크립트가 시작됐어! 이제 에임 연습 시작이다! 'q'를 누르면 언제든지 종료할 수 있어! 😉")
    
    while True:
        loop_start_time = time.time()
        
        # 1. 화면 중앙 박스를 캡처해!
        captured_image = grab_capture_box()
        
        # 2. 이미지를 분석하고 마우스를 조작해줘.
        process_and_aim(captured_image)
        
        # 3. 현재 캡처된 화면을 새로운 창에 보여줘.
        # 이 창을 보면 스크립트가 뭘 인식하고 있는지 알 수 있어!
        cv2.imshow('Game Aim Assist', captured_image)
        
        # 4. 루프가 한 번 도는 데 걸린 시간을 계산해서 FPS(초당 프레임)를 보여줘.
        loop_end_time = time.time()
        fps = 1 / (loop_end_time - loop_start_time)
        print(f"FPS: {fps:.2f} 💨")
        
        # 'q' 키를 누르면 루프를 멈추고 창을 닫아줘.
        if cv2.waitKey(1) & 0xFF == ord("q"):
            cv2.destroyAllWindows()
            break

if __name__ == "__main__":
    main()
